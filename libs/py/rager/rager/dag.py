# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_dag.ipynb.

# %% auto 0
__all__ = ['HookFn', 'Node', 'DAG']

# %% ../nbs/01_dag.ipynb 4
from typing import Any, Callable, List, Optional

import networkx as nx
from pydantic import BaseModel

# %% ../nbs/01_dag.ipynb 5
HookFn = Callable[[Any], Any]

# %% ../nbs/01_dag.ipynb 6
class Node:
    def __init__(
        self,
        id: str,
        dep: Optional[List[str]] = None,
        input_schema: Optional[BaseModel] = None,
        output_schema: Optional[BaseModel] = None,
        post_input_hook: Optional[HookFn] = None,
        post_output_hook: Optional[HookFn] = None,
    ):
        self.input_schema = input_schema
        self.output_schema = output_schema
        self.input_hook = post_input_hook
        self.output_hook = post_output_hook

    def run(self, input, check: bool = True):
        if check and self.input_schema:
            self.input_schema.model_validate(input)

        if self.input_hook:
            input = self.input_hook(input)

        result = self._run(input)

        if self.output_hook:
            result = self.output_hook(result)

        if check and self.output_schema:
            self.output_schema.model_validate(result)

        return result

    def _run(self, _input):
        raise NotImplementedError

# %% ../nbs/01_dag.ipynb 7
class DAG:
    def __init__(self, nodes: List[Node]):
        graph = nx.DiGraph()

        for node in nodes:
            graph.add_node(node.id, node=node)

        for node in nodes:
            if node.dep:
                for dep in node.dep:
                    graph.add_edge(dep, node.id)

        self.graph = graph

    def run(self, input, check: bool = True):
        sorted_graph = nx.topological_sort(self.graph)
        intermediate_results = {}
        results = {}

        for node_id in sorted_graph:
            node = self.graph.nodes[node_id]["node"]

            if self.graph.out_degree(node_id) == 0:
                result = node.run(input, check)
                results[node_id] = result
            else:
                dep_results = [
                    intermediate_results[dep]
                    for dep in self.graph.predecessors(node_id)
                ]
                result = node.run(dep_results, check)
                intermediate_results[node_id] = result

        return results
