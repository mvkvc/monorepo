# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/api/app.ipynb.

# %% auto 0
__all__ = ['app', 'models', 'embed', 'rerank', 'complete', 'chat', 'UploadRequest', 'create_upload_file']

# %% ../../nbs/api/app.ipynb 4
import os
from typing import Optional

import pymupdf
import uvicorn
from fastapi import FastAPI, File, HTTPException, UploadFile

from .lifespan import lifespan
from ..embed import EmbedRequest, embed_supported_models
from ..rerank import RerankRequest
from ..tokens import count_tokens

# %% ../../nbs/api/app.ipynb 5
app = FastAPI(lifespan=lifespan)

# %% ../../nbs/api/app.ipynb 6
@app.get("/models")
async def models():
    embed_clients = app.state.clients["embed"]
    embed_models = [
        k
        for k, v in embed_supported_models.items()
        if v.init_key in embed_clients.keys()
    ]
    return {"embed": embed_models}

# %% ../../nbs/api/app.ipynb 7
@app.post("/embed")
async def embed(req: EmbedRequest):
    if req.model_str not in embed_supported.keys():
        raise HTTPException(status_code=400, detail=f"Unsupported model: {embed.model}")

    model = embed_supported_models[req.model_str]

    if isinstance(req.text, str):
        req.text = [req.text]

    if len(req.text) > model.max_batch:
        raise HTTPException(
            status_code=400,
            detail=f"Batch size {len(req.text)} exceeds model {req.model} max batch {model.max_batch}",
        )

    client = None
    if model.init_key is not None:
        if model.init_key not in app.state.clients.keys():
            raise HTTPException(
                status_code=404, detail=f"Client {model.init_key} not found"
            )
        client = app.state.clients[model.init_key]
        if client is None:
            raise HTTPException(
                status_code=500,
                detail=f"Client '{model.init_key}' is not initialized",
            )

    fn_embed = model.fn_embed(client)

    embeddings = []
    for i, text in enumerate(req.text):
        if count_tokens(text) > model.max_input_size:
            raise HTTPException(
                status_code=400,
                detail=f"Input too long for model {req.model} with max length {model.max_input_size} tokens at index {i}",
            )

        if model.async_:
            embedding = await fn_embed(text)
        else:
            embedding = fn_embed(text)

        embeddings.append(embedding)

    return {"embeddings": embeddings}

# %% ../../nbs/api/app.ipynb 8
@app.post("/rerank")
async def rerank():
    return {"rerank": "not implemented"}

# %% ../../nbs/api/app.ipynb 9
@app.post("/complete")
async def complete():
    return {"complete": "not implemented"}

# %% ../../nbs/api/app.ipynb 10
@app.post("/chat")
async def chat():
    return {"chat": "not implemented"}

# %% ../../nbs/api/app.ipynb 11
class UploadRequest:
    file: UploadFile
    chunk_strategy: Optional[str] = None

# %% ../../nbs/api/app.ipynb 12
@app.post("/upload/chunk_strategy")
async def create_upload_file(file: UploadFile, chunk_strategy: str | None = None):
    if file.content_type == "text/plain":
        contents = await file.read()
    elif file.content_type == "application/pdf":
        contents = pymupdf4llm.to_markdown(file.file)
    else:
        raise HTTPException(
            status_code=400, detail=f"Unsupported file type: {file.content_type}"
        )

# %% ../../nbs/api/app.ipynb 13
# | eval: false
if __name__ == "__main__":
    uvicorn.run(
        "rager.api.app:app",
        host=os.getenv("RAGER_API_HOST", "0.0.0.0"),
        port=os.getenv("RAGER_API_PORT", 8080),
        reload=os.getenv("RAGER_API_RELOAD", False),
    )
