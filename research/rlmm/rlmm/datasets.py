# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_datasets.ipynb.

# %% auto 0
__all__ = ['DatasetSequential', 'DatasetBook', 'DatasetTrades']

# %% ../nbs/02_datasets.ipynb 4
from datetime import datetime
from functools import partial
import os
from typing import *

import dask.dataframe as dd
from fastcore.basics import patch
import numpy as np
from omegaconf import MISSING
import pandas as pd
from pandas.api.types import is_datetime64_any_dtype
from torch.utils.data import Dataset

from .core import *
from .utils import *

# %% ../nbs/02_datasets.ipynb 8
class DatasetSequential(Dataset):
    def __init__(
        self,
        path: str,
        time_start: Union[str, datetime, None] = None,
        time_end: Union[str, datetime, None] = None,
        time_format: str = "%y_%m_%d-%H_%M_%S",
        resample_interval: Optional[str] = None,
        resample_frequency: int = 1,
    ) -> None:
        self.path = path
        self.time_start = time_start
        self.time_end = time_end
        self.time_format = time_format
        self.resample_interval = resample_interval
        self.resample_frequency = resample_frequency

        if not os.path.exists(os.path.abspath(self.path)):
            raise FileNotFoundError(f"File path {self.path} does not exist")

        self.df = dd.read_parquet(self.path, calculate_divisions=True)

        # if not isinstance(self.df.index, dd.DatetimeIndex):
        #     raise ValueError("Index must be a datetime index")
        if not isinstance(self.df.index, dd.Index) and is_datetime64_any_dtype(
            self.df.index.dtype
        ):
            raise ValueError("Index must be a datetime index")

        self.idx_start = self.df.head(1).index[0]
        self.idx_end = self.df.tail(1).index[0]

        if self.time_start is not None:
            if isinstance(self.time_start, str):
                self.time_start = datetime.strptime(self.time_start, self.time_format)
            if self.time_start < self.idx_start:
                raise ValueError("Start time is before starting index")

        if self.time_end is not None:
            if isinstance(self.time_end, str):
                self.time_end = datetime.strptime(self.time_end, self.time_format)
            if self.time_end > self.idx_end:
                raise ValueError("End time is after ending index")

        #         ADD SORTING HERE

        if self.resample_interval is not None:
            # self.df = self.df.set_index(self.df.index, npartitions='auto')
            # self.df = self.df.set_index(self.df.index, sort=True, divisions=self.df.index.compute())
            resample_code = get_resample_code(
                self.resample_interval, self.resample_frequency
            )
            self.df = self.df.resample(resample_code).first()

        self.index = None
        self.length = None

# %% ../nbs/02_datasets.ipynb 10
@patch
def _get_index(self: DatasetSequential) -> pd.Index:
    if self.index is None:
        self.index = self.df.index.compute()

    return self.index

# %% ../nbs/02_datasets.ipynb 11
@patch
def __len__(self: DatasetSequential) -> int:
    return len(self._get_index())

# %% ../nbs/02_datasets.ipynb 12
@patch
def __getitem__(
    self: DatasetSequential, idx: Union[int, datetime, slice]
) -> pd.DataFrame:
    if isinstance(idx, int):
        index = self._get_index()
        return self.df.loc[index[idx]].compute()
    elif isinstance(idx, datetime):
        return self.df.loc[idx].compute()
    elif isinstance(idx, slice):
        if idx.step is not None:
            raise ValueError("slice step is not supported")
        start, stop = idx.start, idx.stop
        if start is None and stop is None:
            return self.df.compute()
        if isinstance(start, (int, np.int64)) and isinstance(stop, (int, np.int64)):
            if not (
                (start < 0 or start >= self.__len__())
                or (stop < 0 or stop >= self.__len__())
            ):
                index = self._get_index()
                return self.df.loc[index[start:stop]].compute()
            else:
                raise ValueError("Start and stop out of range")
        elif isinstance(start, (datetime, np.datetime64)) and isinstance(
            stop, (datetime, np.datetime64)
        ):
            return self.df.loc[start:stop].compute()
        else:
            raise TypeError("start and stop of slice must be int or datetime")
    else:
        raise TypeError("idx must be int, datetime, slice")

# %% ../nbs/02_datasets.ipynb 13
class DatasetBook(DatasetSequential):
    def __init__(
        self,
        path: str,
        time_start: Union[str, datetime, None] = None,
        time_end: Union[str, datetime, None] = None,
        time_format: str = "%y_%m_%d-%H_%M_%S",
        resample_interval: Optional[str] = "minute",
        resample_frequency: int = 1,
        price_levels: int = 10,
        col_prices_ask_re: str = "(?=.*price)(?=.*ask)",
        col_prices_bid_re: str = "(?=.*price)(?=.*bid)",
        col_volumes_ask_re: str = "(?=.*amount)(?=.*ask)",
        col_volumes_bid_re: str = "(?=.*amount)(?=.*bid)",
        col_sort: str = "\d+",
    ):
        super().__init__(
            path=path,
            time_start=time_start,
            time_end=time_end,
            resample_interval=resample_interval,
            resample_frequency=resample_frequency,
            time_format=time_format,
        )

        self.price_levels = price_levels
        self.col_prices_ask_re = col_prices_ask_re
        self.col_prices_bid_re = col_prices_bid_re
        self.col_volumes_ask_re = col_volumes_ask_re
        self.col_volumes_bid_re = col_volumes_bid_re
        self.col_sort = col_sort

        cols_partial = partial(
            list_regex, lst=self.df.columns.to_list(), regex_sort=self.col_sort
        )

        self.cols_prices_ask = cols_partial(regex_match=self.col_prices_ask_re)[
            0 : self.price_levels
        ]
        self.cols_prices_bid = cols_partial(regex_match=self.col_prices_bid_re)[
            0 : self.price_levels
        ]
        self.cols_volumes_ask = cols_partial(regex_match=self.col_volumes_ask_re)[
            0 : self.price_levels
        ]
        self.cols_volumes_bid = cols_partial(regex_match=self.col_volumes_bid_re)[
            0 : self.price_levels
        ]
        self.df = self.df[
            (
                self.cols_prices_ask
                + self.cols_volumes_ask
                + self.cols_prices_bid
                + self.cols_volumes_bid
            )
        ]

# %% ../nbs/02_datasets.ipynb 18
class DatasetTrades(DatasetSequential):
    def __init__(
        self,
        path: str,
        time_start: Union[str, datetime, None] = None,
        time_end: Union[str, datetime, None] = None,
        resample_interval: Optional[str] = None,
        resample_frequency: int = None,
        time_format: str = "%y_%m_%d-%H_%M_%S",
        col_side: str = "side",
        col_price: str = "price",
        col_amount: str = "amount",
    ):
        super().__init__(
            path=path,
            time_start=time_start,
            time_end=time_end,
            resample_interval=resample_interval,
            resample_frequency=resample_frequency,
            time_format=time_format,
        )

        self.col_side = col_side
        self.col_price = col_price
        self.col_amount = col_amount

        self.df = self.df[[self.col_side, self.col_price, self.col_amount]]
