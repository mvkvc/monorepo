# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_envs.ipynb.

# %% auto 0
__all__ = ['side', 'Order', 'BaseEnv', 'OrderBookEnv']

# %% ../nbs/03_envs.ipynb 4
from collections import namedtuple
from typing import *

from fastcore.basics import patch
import gymnasium as gym
import numpy as np
import pandas as pd

from .core import *
from .datasets import *

# %% ../nbs/03_envs.ipynb 6
side = Literal["bid", "ask"]

# %% ../nbs/03_envs.ipynb 8
Order = namedtuple("Order", ["idx", "side", "price", "amount", "ahead", "age"])

# %% ../nbs/03_envs.ipynb 10
class BaseEnv(gym.Env):
    pass

# %% ../nbs/03_envs.ipynb 11
class OrderBookEnv(BaseEnv):
    metadata = {"render_modes": None}

    def __init__(
        self,
        dataset_book: DatasetBook,
        dataset_trades: DatasetTrades,
        initial_cash: float = 1_000_000,
        initial_inventory: float = 100,
        min_value: float = 0,
        order_max_age: Union[int, None] = 10,
        episode_length: Union[int, None] = 100,
        seed: Union[int, None] = 42,
        render_mode: Union[str, None] = None,
    ) -> None:
        self.dataset_book = dataset_book
        self.dataset_trades = dataset_trades
        self.initial_cash = initial_cash
        self.initial_inventory = initial_inventory
        self.min_value = min_value
        self.order_max_age = order_max_age
        self.episode_length = episode_length
        self.seed = seed
        self.render_mode = render_mode

        self.observation_space = gym.spaces.Dict(
            {
                "book_volumes": gym.spaces.Box(
                    low=0, high=np.inf, shape=(self.dataset_book.price_levels * 2,)
                ),
                "order_volumes": gym.spaces.Box(
                    low=0, high=np.inf, shape=(self.dataset_book.price_levels * 2,)
                ),
                "cash": gym.spaces.Box(low=0, high=np.inf, shape=(1,)),
                "inventory": gym.spaces.Box(low=0, high=np.inf, shape=(1,)),
            }
        )

        self.action_space = gym.spaces.Sequence(
            gym.spaces.Tuple(
                (
                    gym.spaces.Discrete(2),
                    gym.spaces.Discrete(self.dataset_book.price_levels),
                    gym.spaces.Box(low=0, high=1, shape=(1,)),
                )
            )
        )

        # Allow having resample `False` in the reset options
        # self.df_book, self.df_trades = self.resample_book(length=self.episode_length)

        assert render_mode is None or render_mode in self.metadata["render_modes"]
        self.render_mode = render_mode

        self.df_book = None
        self.df_trades = None

        self.idx = None
        self.idx_end = None

        self.book_prices_ask = None
        self.book_prices_bid = None
        self.book_volumes_ask = None
        self.book_volumes_bid = None
        self.order_volumes_ask = None
        self.order_volumes_bid = None

        self.midprice = None
        self.cash = None
        self.inventory = None
        self.portfolio_value = None

        self.oid = None
        self.df_orders = None

        self.reset(seed=self.seed, options={"resample": True})

# %% ../nbs/03_envs.ipynb 18
@patch
def resample_book(self: OrderBookEnv, length: Union[int, None] = None) -> pd.DataFrame:
    if length is None:
        df_book = self.dataset_book[:]
    else:
        length_dataset = len(self.dataset_book)
        if length > length_dataset:
            raise ValueError(
                f"Length {length} is greater than dataset length {length_dataset}"
            )

        start = self.np_random.integers(0, length_dataset - length)
        df_book = self.dataset_book[start : start + length]

    df_trades = self.dataset_trades[df_book.index[0] : df_book.index[-1]]

    return df_book, df_trades

# %% ../nbs/03_envs.ipynb 21
@patch
def update_book(self: OrderBookEnv) -> None:
    ts = self.df_book.index[self.idx]
    self.book_prices_bid = self.df_book.loc[
        ts, self.dataset_book.cols_prices_bid
    ].values
    self.book_prices_ask = self.df_book.loc[
        ts, self.dataset_book.cols_prices_ask
    ].values
    self.book_volumes_bid = self.df_book.loc[
        ts, self.dataset_book.cols_volumes_bid
    ].values
    self.book_volumes_ask = self.df_book.loc[
        ts, self.dataset_book.cols_volumes_ask
    ].values

# %% ../nbs/03_envs.ipynb 23
@patch
def get_midprice(self: OrderBookEnv) -> float:
    return (self.book_prices_ask[0] + self.book_prices_bid[0]) / 2

# %% ../nbs/03_envs.ipynb 25
@patch
def get_pv(
    self: OrderBookEnv,
) -> float:
    return self.cash + self.inventory * self.get_midprice()

# %% ../nbs/03_envs.ipynb 27
@patch
def build_df_orders(
    self: OrderBookEnv, orders: Union[List[Order], None] = None
) -> pd.DataFrame:
    out = {"idx": [], "side": [], "price": [], "amount": [], "ahead": [], "age": []}

    if orders is not None:
        for order in orders:
            out["idx"].append(order.idx)
            out["side"].append(order.side)
            out["price"].append(order.price)
            out["amount"].append(order.amount)
            out["ahead"].append(order.ahead)
            out["age"].append(order.age)

    return pd.DataFrame(out)

# %% ../nbs/03_envs.ipynb 30
@patch
def update_order_volumes(self: OrderBookEnv):
    order_volumes_bid = np.zeros(self.dataset_book.price_levels)
    order_volumes_ask = np.zeros(self.dataset_book.price_levels)

    if not self.df_orders.empty:
        order_combos = self.df_orders[["side", "price", "amount"]]
        order_combos_ask = order_combos[order_combos["side"] == "ask"]
        order_combos_bid = order_combos[order_combos["side"] == "bid"]

        if not order_combos_ask.empty:
            order_combos_ask = (
                order_combos_ask[["price", "amount"]].groupby(by="price").sum()
            )
            idx_orders_in_prices = np.where(
                np.isin(self.book_prices_ask, order_combos_ask.index)
            )[0]
            idx_prices_in_orders = np.where(
                np.isin(order_combos_ask.index.values, self.book_prices_ask)
            )[0]

            # print("order_vols: ", order_volumes_ask)
            # print("order_combs: ", order_combos_ask)
            # print(idx_orders_in_prices, idx_prices_in_orders)
            # print(order_volumes_ask[idx_orders_in_prices])
            # print(order_combos_ask["amount"].iloc[
            #         idx_prices_in_orders
            #     ].values)
            if len(idx_orders_in_prices) == len(idx_prices_in_orders) != 0:
                order_volumes_ask[idx_orders_in_prices] = (
                    order_combos_ask["amount"].iloc[idx_prices_in_orders].values
                )

        if not order_combos_bid.empty:
            order_combos_bid = (
                order_combos_bid[["price", "amount"]].groupby(by="price").sum()
            )
            idx_orders_in_prices = np.where(
                np.isin(self.book_prices_bid, order_combos_bid.index)
            )[0]
            idx_prices_in_orders = np.where(
                np.isin(order_combos_bid.index.values, self.book_prices_bid)
            )[0]

            if len(idx_orders_in_prices) == len(idx_prices_in_orders) != 0:
                order_volumes_bid[idx_orders_in_prices] = order_combos_bid[
                    "amount"
                ].iloc[idx_prices_in_orders]

    self.order_volumes_bid = order_volumes_bid
    self.order_volumes_ask = order_volumes_ask

# %% ../nbs/03_envs.ipynb 34
@patch
def get_obs(self: OrderBookEnv) -> np.ndarray:
    return np.concatenate(
        [
            np.flip(self.book_volumes_bid),
            self.book_volumes_ask,
            np.flip(self.order_volumes_bid),
            self.order_volumes_ask,
            np.array([self.cash, self.inventory]),
        ]
    )

# %% ../nbs/03_envs.ipynb 36
@patch
def get_info(self: OrderBookEnv):
    return {
        "idx": self.idx,
        "timestamp": str(self.df_book.index[self.idx]),
        "cash": self.cash,
        "inventory": self.inventory,
        "portfolio_value": self.get_pv(),
        #         "vwap": self.vwap,
        #         "total_reward": self.total_reward,
    }

# %% ../nbs/03_envs.ipynb 38
@patch
def reset(
    self: OrderBookEnv,
    seed: Union[int, None] = None,
    options: Union[Dict, None] = {"resample": False},
):
    super(OrderBookEnv, self).reset(seed=seed)

    if options["resample"]:
        self.df_book, self.df_trades = self.resample_book(length=self.episode_length)

    self.idx = 0
    if self.episode_length is not None:
        self.idx_end = self.idx + self.episode_length
    else:
        self.idx_end = len(self.df_book)

    self.oid = 0
    self.df_orders = self.build_df_orders()

    self.update_book()
    self.update_order_volumes()

    self.cash = self.initial_cash
    self.inventory = self.initial_inventory
    self.portfolio_value = self.get_pv()
    self.total_reward = 0

    obs = self.get_obs()
    info = self.get_info()

    self.state = obs
    self.info = info

    return obs, info

# %% ../nbs/03_envs.ipynb 41
@patch
def build_order(self: OrderBookEnv, side: side, price_level: int, amount: float):
    if side == "bid":
        price = self.book_prices_bid[price_level]
        amount = self.cash * amount / price
    elif side == "ask":
        price = self.book_prices_ask[price_level]
        amount = self.inventory * amount
    else:
        raise ValueError("Invalid side value")

    return Order(idx=self.oid, side=side, price=price, amount=amount, ahead=0, age=0)

# %% ../nbs/03_envs.ipynb 43
@patch
def fill_effects(self: OrderBookEnv, order: Order):
    completed = False
    cash_amount = order.price * order.amount

    if order.side == "bid":
        if self.cash >= cash_amount:
            completed = True
            self.cash -= cash_amount
            self.inventory += order.amount

    elif order.side == "ask":
        if self.inventory >= order.amount:
            completed = True
            self.inventory -= order.amount
            self.cash += cash_amount

    return completed

# %% ../nbs/03_envs.ipynb 47
@patch
def build_df_orders(
    self: OrderBookEnv, orders: Union[List[Order], None] = None
) -> pd.DataFrame:
    out = {"idx": [], "side": [], "price": [], "amount": [], "ahead": [], "age": []}

    if orders is not None:
        for order in orders:
            out["idx"].append(order.idx)
            out["side"].append(order.side)
            out["price"].append(order.price)
            out["amount"].append(order.amount)
            out["ahead"].append(order.ahead)
            out["age"].append(order.age)

    return pd.DataFrame(out)

# %% ../nbs/03_envs.ipynb 50
@patch
def place_orders(self: OrderBookEnv, orders: List[Order]):
    out_orders = []
    for order in orders:
        completed = self.fill_effects(order)
        if completed:
            out_orders.append(order)

    self.df_orders = pd.concat(
        [self.df_orders, self.build_df_orders(out_orders)]
    ).reset_index(drop=True)

    return out_orders

# %% ../nbs/03_envs.ipynb 53
@patch
def process_trades(self: OrderBookEnv):
    if not self.df_trades.empty:
        start_time = self.df_book.index[self.idx]
        end_time = self.df_book.index[self.idx + 1]

        trades = self.df_trades.loc[start_time:end_time]
        trades = trades.replace({"side": {"sell": "ask", "buy": "bid"}})
        trades_sum = trades.groupby(by=["side", "price"])["amount"].sum()
        orders_combos = self.df_orders[["side", "price"]].drop_duplicates()

        # print(orders_combos)
        for side, price in zip(orders_combos.side, orders_combos.side):
            # print(trades_sum)
            trades_lookup = trades_sum.get(("ask", 1549.22), pd.Series([]))

            if trades_lookup.empty:
                return

            # trades_amount = trades_lookup["amount"][0]
            trades_amount = trades_lookup
            orders_lookup = self.df_orders.loc[(side, price)]
            orders_lookup.sort_values(by=["ahead"], inplace=True)

            for oid, order in orders_lookup.iterrows():
                if trades_amount <= 0:
                    break

                ahead = order["ahead"]
                amount = order["amount"]

                if trades_amount <= ahead:
                    self.df_orders.at[oid, "oid"] -= trades_amount
                    trades_amount = 0
                elif (trades_amount > ahead) & ((trades_amount - ahead) <= amount):
                    self.df_orders.loc[order_id, "ahead"] = 0
                    trades_amount -= ahead

                    self.df_orders.loc[order_id, "amount"] -= trades_amount
                    self.fill_effects(side, price, trades_amount)
                    trades_amount = 0
                elif (trades_amount > ahead) & ((trades_amount - ahead) > amount):
                    self.df_orders = self.df_orders[
                        self.df_orders.id != order_id
                    ].reset_index(drop=True)
                    self._fill_effects(side, price, amount)
                    trades_amount -= ahead + amount
            else:
                raise ValueError(trades_amount)

# %% ../nbs/03_envs.ipynb 56
@patch
def gc_orders(self: OrderBookEnv):
    if not self.df_orders.empty:
        exp_orders = self.df_orders[self.df_orders.age > self.order_max_age]
        del_ids = []
        for oid, order in exp_orders.iterrows():
            price = order["price"]
            amount = order["amount"]
            side = order["side"]

            if side == "bid":
                cash = price * amount
                self.cash += cash
            elif side == "ask":
                self.inventory += amount

            del_ids.append(oid)

        self.df_orders = self.df_orders.drop(del_ids).reset_index(drop=True)

# %% ../nbs/03_envs.ipynb 60
@patch
def convert_action(self: OrderBookEnv, action: Tuple[str, float, float]):
    """Convert tuple of (side, price, amount) to order object."""
    side, price, amount = action
    order = self.build_order(side, price, amount)

    return order

# %% ../nbs/03_envs.ipynb 63
@patch
def render_frame(self: OrderBookEnv):
    raise NotImplementedError

# %% ../nbs/03_envs.ipynb 64
@patch
def step(self: OrderBookEnv, actions: List[Tuple[str, float, float]]):
    print(actions)
    act_orders = []
    for action in actions:
        if action is not None:
            order = self.convert_action(action)
            act_orders.append(order)

    # TODO: Review this first section
    completed_orders = self.place_orders(act_orders)

    self.gc_orders()
    self.process_trades()

    if not self.df_orders.empty:
        self.df_orders.age += 1

    self.idx += 1
    done = False
    # TODO: Create new is_done function if more conditions for ending
    if self.idx == self.idx_end or self.portfolio_value < self.min_value:
        done = True

    # TODO: What is the reward function
    current_value = self.get_pv()
    reward = current_value - self.portfolio_value
    self.portfolio_value = current_value
    self.total_reward += reward

    self.update_book()
    self.update_order_volumes()

    observations = self.get_obs()
    info = self.get_info()
    self.state = observations
    self.info = info

    if self.render_mode:
        self.render()

    return observations, reward, done, info

# %% ../nbs/03_envs.ipynb 67
@patch
def render_frame(self: OrderBookEnv):
    raise NotImplementedError

# %% ../nbs/03_envs.ipynb 68
@patch
def render(self: OrderBookEnv):
    if self.render_mode == "human":
        self.render_frame()

# %% ../nbs/03_envs.ipynb 69
@patch
def close(self: OrderBookEnv):
    raise NotImplementedError
